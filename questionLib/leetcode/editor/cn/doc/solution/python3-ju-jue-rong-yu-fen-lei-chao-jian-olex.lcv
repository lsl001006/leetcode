### 解题思路

大部分题解讨论了过多复杂的分类条件，使得这个题好像很难理解。比如，很多题将'X*'的使用情况分为“X出现0次，X出现1次，X出现n次”三类情况。但实际上，“X出现1次”是多余的讨论，我们只需要讨论“不使用X*”和“使用X*”两种，可以大大降低思维难度。

当然，我们仍然需要建立一个二维的`dp[i][j]`数组，以保存动态规划的状态。其中，`dp[i][j]`表示`正则串p的前i个字符`能否配对成功`目标串s的前j个字符]`。
首先，我们讨论最简单的情况，即没出现`*`。这时，我们只需要保证新读入的p串字符和新读入的s串字符能够配对，且`dp[i-1][j-1]`能够配对即可。相信大家很好理解，也可以看代码上的注释。

下面，我们需要讨论遇到`*`的情况。
![QQ截图20220106174455.png](https://pic.leetcode-cn.com/1641462481-UtHRTt-QQ%E6%88%AA%E5%9B%BE20220106174455.png)

我们使用字符串`abbbbc`和正则串`abb*b.`来作为例子说明。首先，我们建立如上图的dp数组，并将首行填充。其中填充第0列时需要注意，如果正则串为`a*b*c*`的形式，其是可以表示 null 串的。

之后，我们依次填充每行数组。当 i<4 时，我们可以很轻易地填好。
![2.png](https://pic.leetcode-cn.com/1641462658-pucoIJ-2.png)

当 i=4 时，`p[i-1] = '*'`，这时，我们要使用`*`之前的字符`p[i-2]`，即'b'与`s[j-1]`检验是否配对。首先与 j=1 处的'a'比较，发现不配对。此时只有一种情况能使p串与s串配对，即**不使用**`b*`，查看 dp[i-2][j]，'ab'与'a'是否配对。dp[2][1] = False，因此，我们将 False 填入 dp[4][1]。这时我们已经归纳出了一个情况的处理方法：**dp[i] 读到'*'且上一个字符 p[i-2] 无法与 s[j-1] 配对时，dp[i][j] = dp[i-2][j]。**

![3.png](https://pic.leetcode-cn.com/1641463166-YfkLcs-3.png)

我们再看s串的下一个字符，j=2，此时 s[j-1] = 'b'，二者能够配对了。我们首先还考虑刚才讨论的情况，即不使用`b*`，我们发现'ab'与'ab'是可以配对的，即 dp[2][2] = True。因此，我们可以直接将dp[4][2]填True。这时，我们又归纳出了另一个处理方法：**dp[i] 读到'*'且上一个字符 p[i-2] 可以与 s[j-1] 配对时，若dp[i-2][j] = True，dp[i][j] = True。**

![4.png](https://pic.leetcode-cn.com/1641463473-DcgfXO-4.png)

我们再接着往下走，j=3，此时 s[j-1] = 'b'，二者仍然能够配对。先看刚才的方法，发现'ab'与'abb'无法配对，即不使用`b*`肯定是不行了。我们现在考虑，如果使用`b*`，我们要从哪里继承状态呢？注意，我们现在能够确定的是，新读入的s串字符是与`*`之前的字符匹配的。如果我们在这里将`b*`中的`b`重复n次，那么意味着左边的格子，即dp[i][j-1]表示将`b`重复n-1次。反过来说，如果可以将`b`重复n-1次，那么在新字符匹配的情况下，肯定能将`b`重复n次。因此，我们直接继承dp[i][j-1]就好。（注意，这里的n-1是可以等于0的。对着图理解，只要我们之前将dp[4][2]填了True，我们之后只要一直从s串中读入的是连续的'b'，那么我们可以一直填True，代表着重复1次、2次、3次......）这时，我们得到了最后一个处理方法：**dp[i] 读到'*'且上一个字符 p[i-2] 可以与 s[j-1] 配对时，若dp[i][j-1] = True，dp[i][j] = True。**

![5.png](https://pic.leetcode-cn.com/1641463996-ZsHLst-5.png)

我们按照之前的方法，可以很顺利地将dp数组填完了。

![6.png](https://pic.leetcode-cn.com/1641464085-hQPhIa-6.png)

很多题解多分了一些类别，其实是没有必要的。

### 代码

* python3

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:

        def match(charS: str, charP: str) -> bool:
            '''当正则字符为‘.’，或二者字符相等时，返回True'''
            return charP == '.' or charP == charS


        # dp[i][j]表示 [正则串p的前i个字符] 能否配对成功 [目标串s的前j个字符]
        # 为了更多的cache hit，我们将逐个遍历i，即逐个读入p串的字符
        lenS, lenP = len(s), len(p)
        dp = [[False] * (lenS+1) for _ in range(lenP+1)]

        # 空字符配对空字符则必定成功
        dp[0][0] = True

        # 如果正则串为‘X*X*X*...’的形式，则其可配对空字符串
        for i in range(1, lenP+1):
            if p[i-1] == '*':
                dp[i][0] = dp[i-2][0]
        
        for i in range(1, lenP+1):
            for j in range(1, lenS+1):
                
                # 如果p新读入的字符是'*'，则需要比对'*'之前的字符与s的相应字符
                if p[i-1] == '*':

                    # 1. 如果两个字符能够配对，我们用'X'表示这个字符，有两种情况：
                    # 1.1. 不使用'X*'，即p串除去'X*'的部分可以与s串配对，即dp[i-2][j]
                    # 1.2. 使用'X*'，因为我们已经确定'X'能够与s串的字符配对，因此，
                    #      只要p串之前的某一个字符与s串的这个字符配对成功过，之后'*'这行所有
                    #      能够配对的字符都能配对成功，dp[i][j-1]
                    #      e.g. 'ab*' 只要与'abbbb...'在第三行第一列配对成功了，即'ab*'与'a'的dp[3][1]
                    #           之后对于所有'bbbbb...'，dp[3][...]都是True
                    if match(s[j-1], p[i-2]):
                        dp[i][j] = dp[i-2][j] or dp[i][j-1]
                    
                    # 2. 如果两个字符配对不成功
                    # 2.1. 此时只有不使用'X*'一种方法能够使p,s配对，即dp[i-2][j]
                    else:
                        dp[i][j] = dp[i-2][j]
                
                # 如果p新读入的不是'*'，就很简单了，只要[配对]且[二者上一个字符能够配对]就可以
                else:
                    dp[i][j] = match(s[j-1], p[i-1]) and dp[i-1][j-1]
        
        return dp[-1][-1]


```

